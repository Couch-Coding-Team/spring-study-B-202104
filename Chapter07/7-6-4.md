# 7.6.4 프로파일

- 테스트에서 사용되는 빈 설정을 TestAppContext 로 분리했는데 이거 하나면 애플리케이션 동작에 필요 핵심 빈 설정 충분
- 여기서 문제가 발생
- 운영 시스템에서는 실제 동작하는 메일 서버를 통해 메일을 발송하는 기능이 잇는 메일 발송 서비스 빈이 필요
- MailSender 타입의 빈은 TestAppContext에만 존재
- 운영환경에서 TestAppContext 없이 AppContext 만 DI 설정정보로 지정하면 어떻게 될까?
- AppContext 에는 메일 서비스를 제공하는 MailSender  타입 빈이 존재하지 않으니 이 빈에 의존하는 userService  빈에서 에러가 발생할 것
- 그래서 AppContext 에 실제 애플리케이션이 동작할 때 사용될 MailSender 타입 빈 설정을 넣어줘야 함

![7%206%204%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20f4a566203dc246e9b53f03940a51e433/Untitled.png](7%206%204%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20f4a566203dc246e9b53f03940a51e433/Untitled.png)

- 이제 AppContext에도 MailSender 타입 빈이 있으니 AppContext 만 가져다 사용해도 메일 발송 기능에는 문제가 발생하지 않을 것
- 그러나 이렇게 하면 테스트에 문제가 생김
- UserServiceTest 를 실행할 때는 AppContext 와 TestAppContext 에 정의된 빈들이 함께 사용됨
- 그래서 Appcontext에 추가한 운영용 mailSender 빈도 테스트 중에 만들어진다
- 테스트용으로 TestAppContext에 정의해둔 mailSender 빈과 충돌이 일어날 수밖에 없다
- 같은 타입이면서 아이디도 같은 두 개의 빈이 있으면 스프링이 빈 정보를 읽는 순서에 따라 뒤의 빈 설정이 앞에서 발견된 빈 설정에 우선해서 적용
- 그래서 7-111과 같은 순서로 설정 클래스를 배열하면 TestAppContext에 정의된 mailSender 대신 AppContext에 추가한 운영용 mailSender 빈이 테스트에 사용되는 문제가 발생

    ![7%206%204%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20f4a566203dc246e9b53f03940a51e433/Untitled%201.png](7%206%204%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20f4a566203dc246e9b53f03940a51e433/Untitled%201.png)

- 테스트 환경과 운영환경에서 각기 다른 빈 정의가 필요한 경우가 종종 있다
- 양쪽 모두 필요하면서 빈의 내용이 달라져야 할 경우엔 빈 설정정보 작성이 곤란해짐
- 이 문제를 해결하려면 운영환경에서는 반드시 필요하지만 테스트 실행 중에는 배제돼야 하는 빈 설정을 변도의 설정 클래스를 만들어 따로 관리할 필요가 있음
- 아래와 같이 mailSender 빈 설정을 해줄 필요가 잇음

![7%206%204%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20f4a566203dc246e9b53f03940a51e433/Untitled%202.png](7%206%204%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20f4a566203dc246e9b53f03940a51e433/Untitled%202.png)

- ProductionAppContext 도 SqlServiceContext처럼 AppContext에서 @Import 로 가져오게 할 수 있을까? ⇒ 안됨 ⇒ AppContext는 테스트에도 쓰이기 때문
- 실행환경이나 기능에 따라서 설정파일이 여러 개로 쪼개지고 그중 몇개를 선택해서 동작하도록 구성하는 일은, 특히 애플리케이션 구조가 커지고 모듈이 많아지고 스프링 컨테이너가 동작하는 환경도 단순히 테스트와 운영 두 가지 이상이 될 수 있기에 위의 파일 조합을 이용한 DI 설정은 불편

@Profile 과 @ActiveProfiles

- 스프링 3.1은 환경에 따라서 빈 설정 정보가 달라져야 하는 경우에 간단히 설정정보를 구성할 수 잇는 방법을 제공
- 실행환경에 따라 빈 구성이 달라지는 내용을 프로파일로 정의하고, 실행 시점에 어떤 프로파일의 빈 설정을 사용할지 지정하는 것
- 프로파일은 간단한 이름과 빈 설정으로 구성됨
- 명시적으로 파일을 매번 조합해야 함
- 프로파일을 적용하면 하나의 설정 클래스만으로 환경에 따라 다른 빈 설정 조합을 만들어낼 수 있음

    ![7%206%204%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20f4a566203dc246e9b53f03940a51e433/Untitled%203.png](7%206%204%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20f4a566203dc246e9b53f03940a51e433/Untitled%203.png)

- TestAppContext 는 test 프로파일의 빈 설정정보를 담은 클래스가 됨
- 같은 방법으로 ProductionAppContext는 production 프로파일로 지정할 수 있지만  스프링 3.1에서는 프로파일이 지정되어 있지 않은 빈 설정은 default 프로파일로 취급해서 굳이 안해줘도 됨
- 프로파일을 적용하면 모든 설정 클래스를 부담없이 메인 설정 클래스에서 @Import 해도 되는 장점이 잇음

![7%206%204%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20f4a566203dc246e9b53f03940a51e433/Untitled%204.png](7%206%204%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20f4a566203dc246e9b53f03940a51e433/Untitled%204.png)

- 이제 AppContext가 모든 설정 클래스를 @Import 하고 잇으니 테스트의 @Context Configuration에 더 이상 TestAppcontext를 넣을 필요가 없음

@ContextConfiguration(classes=AppContext.class)

이렇게 수정하면 됨

- 이 상태로 테스트 돌리면 실패함
- mailsender 빈은 Appcontext가 @Import 하는 TestAppContext와 ProductionAppcontext 에 모두 존재하는데도 이 빈을 찾을수 없음

⇒ 왜냐하면 이 두 개의 설정 클래스는 프로파일이 지정되어 있어서 현재 테스트 설정 가지고는 어느 것도 포함되지 않기 때문

- @Profile 이 붙은 설정 클래스는 @Import 로 가져오든 @ContextConfiguration에 직접 명시하든 상관없이 현재 컨테이너의 활성 프로파일 목록에 자신의 프로파일 이름이 들어 잇지 않으면 무시
- 활성 프로파일 = 스프링 컨테이너를 실행할 때 추가로 지정해주는 속성
- @ActiveProfiles 어노테이션을 사용해서 UserDaoTest나 UserServiceTest 가 실행될 때 활성 프로파일로 test 프로파일을 지정하자
- 

![7%206%204%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20f4a566203dc246e9b53f03940a51e433/Untitled%205.png](7%206%204%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20f4a566203dc246e9b53f03940a51e433/Untitled%205.png)

![7%206%204%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20f4a566203dc246e9b53f03940a51e433/Untitled%206.png](7%206%204%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20f4a566203dc246e9b53f03940a51e433/Untitled%206.png)

<컨테이너의 빈 등록 정보 확인>

- 그런데 정말 활성 프로파일이 제대로 적용돼서 지정한 프로파일의 빈 설정만 적용되고 나머지는 무시됐을까?
- 의도한 빈 정보만 적용됐는지 어떻게 알 수 있을까?
- 스프링 컨테이너는 모두 BeanFactory라는 오브젝트 팩토리 인터페이스를 구현하고 있다.
- DefaultListableBeanFactory 는 거의 대부분의 스프링 컨테이너에서 이 클래스를 이용해 빈을 등록하고 관리, 빈클래스 정보 조회 가능
- 오브젝트를 @Autowired  로 주입받아서 이용할 수 있음

![7%206%204%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20f4a566203dc246e9b53f03940a51e433/Untitled%207.png](7%206%204%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20f4a566203dc246e9b53f03940a51e433/Untitled%207.png)

![7%206%204%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20f4a566203dc246e9b53f03940a51e433/Untitled%208.png](7%206%204%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20f4a566203dc246e9b53f03940a51e433/Untitled%208.png)

- bean() 실행하면 테스트 컨텍승트에 등록된 빈 이름과 빈의 클래스를 모두 얻을 수 잇음

<중첩 클래스를 이용한 프로파일 적용>

- 그런데 역시 파일이 많아지니 전체 구성을 살펴보기가 조금 번거로움, 한눈 비교가 불가능
- 그래서 이번에는 프로파일에 따라 분리했던 설정정보를 하나의 파일로 모아봄
- 프로파일이 지정된 독립된 설정 클래스의 구조 그대로, 소스코드의 위치만 통합
- 

![7%206%204%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20f4a566203dc246e9b53f03940a51e433/Untitled%209.png](7%206%204%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20f4a566203dc246e9b53f03940a51e433/Untitled%209.png)

- 두 개의 클래스에 static 만 붙여서 AppContext 로 가져온 뒤 @Import 에 지정했던 클래스를 내부로 이동시킨 클래스로 바꿔주기만 하면 된다
- 이제 AppContext만 열어보면 좀 더 쉽게 볼 수 있음
- 중첩 맴버 클래스로 프로파일 설정 클래스를 포함시키면 @Import 에 지정했던 두 개의 프로파일 설정 클래스를 아예 제거해도 됨
- @Import(SqlServiceContext.class)
- 스태틱 중첩 클래스로 넣은 @Configuration 클래스는 스프링이 자동으로 포함해주기 때문에 문제 없음

![7%206%204%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20f4a566203dc246e9b53f03940a51e433/Untitled%2010.png](7%206%204%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20f4a566203dc246e9b53f03940a51e433/Untitled%2010.png)
