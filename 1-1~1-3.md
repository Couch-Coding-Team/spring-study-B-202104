# 1. 오브젝트와 의존관계

>스프링은 자바로 한 기술이며, 스프링이 자바에서 가장 중요하게 가치를 두는 것은 자바가 객체 지향 프로그래밍이 가능한 언어라는 점이다. 
>그래서 스프링이 가장 관심을 많이 두는 대상은 오브젝트이다. 
>오브젝트가 생성되고, 다른 오브젝트와 관계를 맺고, 사용되고, 소멸하기까지의 과정을 알게 된다면 스프링을 이해할 수 있을 것이다.
>스프링은 객체 지향 설계와 구현에 관해 특정한 모델과 기법을 억지로 강요하지 않고, 오브젝트를 효과적으로 설계하고, 구현하고, 사용하고, 개선해 나갈 것인가에 대한 기준을 마련해준다.

## 1.1 초난감 DAO

- DAO(Data Access Object) : 데이터 베이스를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트를 말한다.

### 1.1.1 User

- 먼저 사용자 정보를 저장할 User 클래스를 만든다. User 클래스는 id, name, password 세개의 프로퍼티를 가진다.

```java
package springbook.user.domain;

public class User { 

    String id;
    String name;
    String password;

    public String getId() { return id; } 
    public void setId(String id) { this.id = id; } 
    public String getName() { return name; }
    public void setName(String name) { this.name = name; } 
    public String getPassword() { return password; } 
    public void setPassword(String password) { this.password = password; } 

}
```
![image](https://user-images.githubusercontent.com/37647995/115255247-07d57600-a169-11eb-9cf7-6dbe9d23f83e.png)
```sql
create table users(
	id varchar(10) primary key,
	name varchar(20) not null,
	password varchar(10) not null
)
```

### 1.1.2 UserDao

- JDBC를 이용하는 작업의 일반적인 순서
  1. DB 연결을 위한 Connection을 가져온다.
  2. SQL을 담은 Statement를 만들고 실행한다.
  3. 조회의 경우 SQL 쿼리 실행 결과를 Result Set으로 받아서 정보를 저장할 오브젝트에 옮겨준다.
  4. 작업중에 생성된 리소스(Connection, Statement, ResultSet) 들은 작업을 마친 후 반드시 닫아준다.
  5. JDBC API가 만들어 내는 예외를 직접 처리하거나, 메소드에 throws를 선언하여 예외가 발생하면 메소드 밖으로 던지게 한다.

```java
//JDBC API의 기본적인 사용방법을 따라서 만든 UserDao
package springbook.user.dao;
...
public class UserDao { 
	
      public void add(User user) throws ClassNotFoundException, SQLException {

        Class.forName("com.mysql.jdbc.Driver");
        Connection c = DriverManager.getConnection( "jdbc:mysql://localhost/springbook", "spring", "book");
        PreparedStatement ps = c.prepareStatement( "insert into users(id, name, password) values(?,?,?)");

        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());
        ps.executeUpdate();

        ps.close();
        c.close();
		}
		
		public User get(String id) throws ClassNotFoundException, SQLException { 
        Class.forName("com.mysql.jdbc.Driver");
        Connection c = DriverManager.getConnection( "jdbc:mysql://localhost/springbook", "spring", "book");
        PreparedStatement ps = c.prepareStatement( "select * from users where id = ?");

        ps.setString(1, id);

        ResultSet rs = ps.excueteQuery();

        rs.next();

        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));

        rs.close();
        ps.close();
        c.close();

        return user;
     } 
}
```

### 1.1.3 main()을 이용한 DAO 테스트 코드

```java
public static void main(String[] args) throws ClassNotFoundException, SQLException { 

      UserDao dao = new UserDao();
      User user = new User();

      user.setId("whiteship");
      user.setName("백기선");
      user.setPassword("married");
      dao.add(user);

      System.out.println(user.getId() + " 등록 성공");

      User user2 = dao.get(user.getId());

      System.out.println(user2.getName());
      System.out.println(user2.getPassword());
      System.out.println(user2.getId() + " 조회 성공");

}
```

- User 오브젝트를 생성하고 프로퍼티에 값을 넣은 다음 add() 메소드를 이용해서 DB에 등록해본다.
- Connection 설정과 코드에 이상이 없다면 main() 메소드는 에러 없이 종료될 것이다.
- 조회용으로 만든 get() 메소드를 통해 DB에 결과가 잘 저장 되었는지 확인해 본다.

>우리가 작성한 DAO 코드는 기능적으로는 정상적으로 잘 작동하지만 문제점을 가지고 있는 코드이다. 기능이 잘 작동하는데 왜 문제점이 많다고 하는 것일까? 
>잘 동작하는 코드를 수정하고 개선해야 하는 이유는 무엇일까? 그렇게 이 코드를 개선해서 얻는 장점은 무엇일까? 
>이 코드를 개선하는 경우와 그대로 사용하는 경우, 스프링을 사용하는 개발에는 무슨 차이가 있을까?
>**스프링을 공부한다는 것은 이런 문제 제기와 의문에 대한 답을 찾아나가는 과정이다.**

## 1.2 DAO의 분리

### 1.2.1 관심사의 분리

개발자는 객체를 설계할 때 가장 염두에 둬야 할 사항은 바로 미래의 변화를 어떻게 대비할 것인가 이다. 
> *두 명의 개발자에게 기능 변경 요청을 했는데, 한 명은 단 몇 줄의 코드를 수정하여 검증하는데 5분 정도의 시간이 소요되었다. 그런데 다른 개발자는 코드 수정만 5시간이 걸리고, 잘 동작하는지 검증도 못하였다.* 

이 예시를 보았을 때, 미래의 변화를 더 잘 준비한 개발자는 최소한의 작업으로 검증까지 마친 개발자이다. 
그러면 어떻게 변경 작업을 최소화 하였고, 그 변경 작업이 문제를 일으키지 않게 할 수 있었을까? 그것은 **분리와 확장**을 고려한 설계가 있었기 때문이다.

변화는 대체로 집중된 한 가지 관심에 대해 일어나기 때문에 관심이 같은 것끼리는 하나의 객체 안으로 모이게 하고, 관심이 다른 것은 가능한 따로 떨어져 영향을 주지 않도록 분리해야 한다.

### 1.2.2 커넥션 만들기의 추출

- 현재 UserDao 코드는 예외상황에 대한 처리가 없다.(뒷 부분에서 다룰 예정)
- UserDao의 구현된 메소드를 보면 add() 메소드 하나에서만 적어도 세가지 관심 사항을 발견할 수 있다.
1. DB와 연결을 위한 커넥션을 가져오는 것
  - Connection 오브젝트를 가져오는 부분은 add(), get() 메소드에 중복으로 작성되어 있다. 
  지금은 두 개의 메소드 밖에 없어서 큰 문제가 되지 않지만, 수백개의 DAO를 만들게 된다면 문제를 일으킬 것이다.
  - 해결 방법 : 중복 코드의 메소드 추출<br>
    중복된 DB 연결 코드를 getConnection()이라는 이름의 독립적인 메소드로 만들어둔다. 각 DAO 메소드에서는 이렇게 분리한 getConnection() 메소드를 호출해서 DB 커넥션을 가져오게 만든다.
    관심의 종류에 따라 코드를 분리해 놓았기 때문에 한 가지 관심에 대한 변경이 일어날 경우 그 관심이 집중되는 부분의 코드만 수정하면 된다. 관심이 다른 코드에 영향을 주지도 않으며, 관심 내용이 독립적으로 존재하기 때문에 수정도 간단해졌다.
![image](https://user-images.githubusercontent.com/37647995/115255820-9fd35f80-a169-11eb-8475-3dc5897aa734.png)
        
>변경사항에 대한 검증 : 리팩토링과 테스트<br>
>코드 수정 후에는 기능에 문제가 없다는 게 보장되지 않는다. 수정한 코드의 검증은 다시 main() 메소드를 실행해서 처음과 같은 결과가 화면에 출력되는지 확인해보면 된다.<br>
>방금 수정한 작업은 **리팩토링**으로, 기능의 영향을 주지 않으면서 코드의 구조만 변경하게 된다. <br>
>(공통의 기능을 담당하는 메소드로 중복된 코드를 뽑아내는 것을 리팩토링에서는 **메소드 추출 기법**이라고 부른다.)<br>
>우리는 DAO 코드를 개선해 나가는 과정에서 기능을 추가하고 변경하기 보다는, 겉으로 드러나는 기능은 그대로지만 코드 구조와 구현 방법을 바꿈으로써 더 나은 DAO를 만들어나가는데 집중할 것이다. 
>앞으로 이런 작업을 리팩토링 한다고 이야기하겠다.<br>

2. DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행하는 것
3. 작업이 끝나면 사용한 리소스를 닫아서 시스템에 돌려주는 것

### 1.2.3 DB 커넥션 만들기의 독립

>예제를 위한 상황을 가정해보자. UserDao를 구매하겠다는 주문이 들어왔지만 문제가 발생했다.
>- 문제점1 : 각기 다른 두 회사가 다른 종류의 DB를 사용하고 있음
>- 문제점2 : UserDao를 구매한 이후에도 DB 커넥션을 가져오는 방법이 변경될 가능성이 있음.
>- 문제점3: UserDao의 코드를 고객에게 공개하고 싶지 않음, 고객에게는 컴파일된 클래스 바이너리 파일만 제공하고 싶음

- 해결 방법 : 상속을 통한 확장<br>
  UserDao에서 메소드의 구현 코드를 제거하고 getConnection()을 추상 메소드로 만들어 놓는다. 이렇게 하게 되면 UserDao의 소스코드를 제공해서 수정하지 않아도 getConnection() 메소드를 원하는 방식으로 확장 후에 UserDao의 기능과 함께 사용할 수 있다.
![image](https://user-images.githubusercontent.com/37647995/115256027-d315ee80-a169-11eb-8cab-a9d021193c7c.png)
![image](https://user-images.githubusercontent.com/37647995/115256040-d610df00-a169-11eb-9677-38a1b0ebebe0.png)


- 템플릿 메소드 패턴 : 슈퍼 클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브 클래스에서 필요에 맞게 구현해서 사용하는 방법
- 팩토리 메소드 패턴 : 서브 클래스의 구체적인 오브젝트 생성 방법을 결정하게 하는 것
ex) UserDao의 서브클래스의 getConnection() 메소드는 어떤 Connection 클래스의 오브젝트를 어떻게 생성할 것인지를 결정하는 방법이다.

## 1.3 DAO의 확장
추상 클래스를 만들고 이를 상속한 서브 클래스에서 변화가 필요한 부분을 바꿔서 쓸 수 있게 만든 이유는 변화의 성격이 다른 것들을 분리해서, 서로 영향을 주지 않은 채로 각각 필요한 시점에 독립적으로 변경할 수 있게 하기 위해서 이지만 여러가지 단점이 많은 상속이라는 방법을 사용했다는 점이 불편하다.

### 1.3.1 클래스의 분리
- DB 커넥션과 관련된 부분을 서브 클래스가 아니라, 아예 별도의 클래스에 담는다.
