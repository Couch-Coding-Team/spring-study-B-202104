# 1.2.3 어노테이션 @Autowired/ @Inject

- 어노테이션을 이용한 의존관계 설정 2번째 방법
- 스프링으로 개발한 POJO 를 앞으로 다른 환경에서도 사용할 가능성이 있다면 inject 와 DIJ에서 정의한 어노테이션을 사용하는게 좋음
- @Autowired 는 XML 의 타입에 의한 자동와이어링 방식을 생성자, 필드, 수정자 메소드, 일반 메소드 네가지로 확장

<수정자 메소드와 필드>

- 필드와 수정자 메소드는  Resource와 사용방법이 비슷
- Autowired 어노테이션이 부여된 필드나 수정자를 만들어주면 스프링이 자동으로 DI 해주도록 만드는 것
- Resource 와 다른 점은 이름 대신 필드나 프로퍼티 타입을 이용해 후보 빈을 찾는다는 것

![1%202%203%20%E1%84%8B%E1%85%A5%E1%84%82%E1%85%A9%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20@Autowired%20@Inject%20ce346e5a69a447abb46e3cb3cb1cf3d9/Untitled.png](1%202%203%20%E1%84%8B%E1%85%A5%E1%84%82%E1%85%A9%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20@Autowired%20@Inject%20ce346e5a69a447abb46e3cb3cb1cf3d9/Untitled.png)

<생성자>

- 생성자의 모든 파라미터에 타입에 의한 자동와이어링이 적용

![1%202%203%20%E1%84%8B%E1%85%A5%E1%84%82%E1%85%A9%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20@Autowired%20@Inject%20ce346e5a69a447abb46e3cb3cb1cf3d9/Untitled%201.png](1%202%203%20%E1%84%8B%E1%85%A5%E1%84%82%E1%85%A9%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20@Autowired%20@Inject%20ce346e5a69a447abb46e3cb3cb1cf3d9/Untitled%201.png)

- @Autowired 는 단 하나의 생성자에만 사용할 수 있다는 제한
- 수정자 또는 필드를 이용한 DI 방식보다는 생성자 주입을 선호한다면 @Autowired 사용 추천

<일반 메소드>

- 생성자 주입과 수정자 메소드의 주입은 각기 장단점이 있기 때문에 두가지 장점을 섞은 일반 메소드로 DI 하는 방법이 있음
- 파라미터를 가진 메소드를 만들고 @Autowired 를 붙여주면 각 파라미터의 타입을 기준으로 자동와이어링을 해서 DI 해줄 수 있음
- 오브젝트 생성 후에 차례로 호출이 가능하므로 여러 개를 만들어도 되서 상대적으로 깔끔해짐

![1%202%203%20%E1%84%8B%E1%85%A5%E1%84%82%E1%85%A9%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20@Autowired%20@Inject%20ce346e5a69a447abb46e3cb3cb1cf3d9/Untitled%202.png](1%202%203%20%E1%84%8B%E1%85%A5%E1%84%82%E1%85%A9%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20@Autowired%20@Inject%20ce346e5a69a447abb46e3cb3cb1cf3d9/Untitled%202.png)

- public 일 필요 없음(그러나 권장)
- 타입이 동일한 빈이 여러 개일 가능성이 있어 타입에 의한 자동와이어링은 고려할 점 많음

<컬렉션과 배열>

- @Autowired 를 이용하면 같은 타입의 빈이 하나 이상 존재할 때 그 빈들을 모두 DI 받도록 할 수 있다
- @Autowired 의 대상이 되는 필드나 프로퍼티, 메소드의 파라미터를 컬렉션이나 배열로 선언

![1%202%203%20%E1%84%8B%E1%85%A5%E1%84%82%E1%85%A9%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20@Autowired%20@Inject%20ce346e5a69a447abb46e3cb3cb1cf3d9/Untitled%203.png](1%202%203%20%E1%84%8B%E1%85%A5%E1%84%82%E1%85%A9%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20@Autowired%20@Inject%20ce346e5a69a447abb46e3cb3cb1cf3d9/Untitled%203.png)

- 의도적으로 타입이 같은 여러 개의 빈을 등록하고 이를 모두 참조하거나 그중에 선별적으로 필요한 빈을 찾을 때 사용하는 것이 좋음
- DI 할 빈의 타입이 컬렉션인 경우에는 @Autowired 로 자동설정이 불가능함을 주의함
- @Autowired 에 컬렉션을 사용했을 때는 같은 타입의 빈이 여러 개 존재해서 이를 모두 DI 하는 것으로 봄

<@Qualifier>

- 타입 외의 정보를 추가해서 자동와이어링을 세밀하게 제어할 수 있는 보조적인 방법
- 타입에 의한 자동와이어링은 안전하고 편리하지만 타입만으로 원하는 빈을 지정하기 어려운 경우가 종종 발생

![1%202%203%20%E1%84%8B%E1%85%A5%E1%84%82%E1%85%A9%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20@Autowired%20@Inject%20ce346e5a69a447abb46e3cb3cb1cf3d9/Untitled%204.png](1%202%203%20%E1%84%8B%E1%85%A5%E1%84%82%E1%85%A9%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20@Autowired%20@Inject%20ce346e5a69a447abb46e3cb3cb1cf3d9/Untitled%204.png)

- @Component 도 마찬가지로 위 어노테이션으로 구분해주면 됨

![1%202%203%20%E1%84%8B%E1%85%A5%E1%84%82%E1%85%A9%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20@Autowired%20@Inject%20ce346e5a69a447abb46e3cb3cb1cf3d9/Untitled%205.png](1%202%203%20%E1%84%8B%E1%85%A5%E1%84%82%E1%85%A9%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20@Autowired%20@Inject%20ce346e5a69a447abb46e3cb3cb1cf3d9/Untitled%205.png)

![1%202%203%20%E1%84%8B%E1%85%A5%E1%84%82%E1%85%A9%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20@Autowired%20@Inject%20ce346e5a69a447abb46e3cb3cb1cf3d9/Untitled%206.png](1%202%203%20%E1%84%8B%E1%85%A5%E1%84%82%E1%85%A9%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20@Autowired%20@Inject%20ce346e5a69a447abb46e3cb3cb1cf3d9/Untitled%206.png)

![1%202%203%20%E1%84%8B%E1%85%A5%E1%84%82%E1%85%A9%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20@Autowired%20@Inject%20ce346e5a69a447abb46e3cb3cb1cf3d9/Untitled%207.png](1%202%203%20%E1%84%8B%E1%85%A5%E1%84%82%E1%85%A9%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20@Autowired%20@Inject%20ce346e5a69a447abb46e3cb3cb1cf3d9/Untitled%207.png)

- 프로퍼티의 DI를 선택적으로 가능하게 하려면 required = false 지정해주면 됨

<@Inject>

- 필드, 생성자, 수정자와 임의의 설정용 메소드에 사용돼서 타입에 의한 자동와이어링을 선언한다는 점에서 자동와이어링과 비슷
- required 엘리먼트는 없음
- @javax.inject.Qualifier 에서 스프링에 독립적인 DI 설정을 가진 클래스를 만들 생각이 아니라면 @Autowired 와 @Qualifier 를 사용하는 편이 나음

<@Autowired 와 getBean(), 스프링 테스트>

- 자동와이어링은 스프링에서 가장 유연하면서 가장 강력한 기능을 가진 의존관계 설정 방법
- 타입에 의한 자동와이어링은 변경되기 쉬운 이름에 의한 자동와이어링이나 명시적인 의존관계 설정보다 편리하다

![1%202%203%20%E1%84%8B%E1%85%A5%E1%84%82%E1%85%A9%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20@Autowired%20@Inject%20ce346e5a69a447abb46e3cb3cb1cf3d9/Untitled%208.png](1%202%203%20%E1%84%8B%E1%85%A5%E1%84%82%E1%85%A9%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20@Autowired%20@Inject%20ce346e5a69a447abb46e3cb3cb1cf3d9/Untitled%208.png)

- 아래 처럼 사용해도 되지만 같은 타입의 빈이 두 개 이상이라면 에러가 발생
- 테스트 클래스의 오브젝트에 어노테이션을 이용한 의존관계 설정을 해준다

![1%202%203%20%E1%84%8B%E1%85%A5%E1%84%82%E1%85%A9%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20@Autowired%20@Inject%20ce346e5a69a447abb46e3cb3cb1cf3d9/Untitled%209.png](1%202%203%20%E1%84%8B%E1%85%A5%E1%84%82%E1%85%A9%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20@Autowired%20@Inject%20ce346e5a69a447abb46e3cb3cb1cf3d9/Untitled%209.png)

<자바 코드에 의한 의존관계 설정>

 1) 어노테이션에 의한 설정 @Autowired , @Resource

![1%202%203%20%E1%84%8B%E1%85%A5%E1%84%82%E1%85%A9%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20@Autowired%20@Inject%20ce346e5a69a447abb46e3cb3cb1cf3d9/Untitled%2010.png](1%202%203%20%E1%84%8B%E1%85%A5%E1%84%82%E1%85%A9%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20@Autowired%20@Inject%20ce346e5a69a447abb46e3cb3cb1cf3d9/Untitled%2010.png)

![1%202%203%20%E1%84%8B%E1%85%A5%E1%84%82%E1%85%A9%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20@Autowired%20@Inject%20ce346e5a69a447abb46e3cb3cb1cf3d9/Untitled%2011.png](1%202%203%20%E1%84%8B%E1%85%A5%E1%84%82%E1%85%A9%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20@Autowired%20@Inject%20ce346e5a69a447abb46e3cb3cb1cf3d9/Untitled%2011.png)

 2) @Bean 메소드 호출

![1%202%203%20%E1%84%8B%E1%85%A5%E1%84%82%E1%85%A9%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20@Autowired%20@Inject%20ce346e5a69a447abb46e3cb3cb1cf3d9/Untitled%2012.png](1%202%203%20%E1%84%8B%E1%85%A5%E1%84%82%E1%85%A9%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20@Autowired%20@Inject%20ce346e5a69a447abb46e3cb3cb1cf3d9/Untitled%2012.png)

- 이 방법은 자바 코드로 DI하는 가장 직관적인 방법
- 스프링의 특별한 목적을 위해 사용되는 코드로 받아들이지 않으면 설정정보에 대해 오해할 소지가 있어 @Configuration 과 자바 코드를 이용한 설정 방식은 주의해서 다뤄줘야 함

 3) @Bean 과 메소드 자동와이어링

- 2번째 방법의 극복방안
- 메소드로 정의된 다른 빈을 가져와 자바 코드로 의존정보를 생성 할 때 직접 @Bean이 붙은 메소드를 호출하는 대신 그 빈의 레퍼런스를 파라미터로 주입받는 방식을 사용하는 것

![1%202%203%20%E1%84%8B%E1%85%A5%E1%84%82%E1%85%A9%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20@Autowired%20@Inject%20ce346e5a69a447abb46e3cb3cb1cf3d9/Untitled%2013.png](1%202%203%20%E1%84%8B%E1%85%A5%E1%84%82%E1%85%A9%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20@Autowired%20@Inject%20ce346e5a69a447abb46e3cb3cb1cf3d9/Untitled%2013.png)

- 이 방식의 장점은 다른 빈의 레퍼런스를 메소드 호출이 아니라 파라미터로 받기 때문에 @Bean 메소드 호출을 이용했을 때보다 자바 코드가 자연스러움
- @Qualifier 파라미터에 추가 가능, 한 개 이상의 파라미터를 사용할수도 있음

<빈 의존관계 설정 전략>

  1) XML 단독

  2) XML과 어노테이션 설정의 혼합

  3) 어노테이션 단독