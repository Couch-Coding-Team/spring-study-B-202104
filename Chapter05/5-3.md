# 서비스 추상화와 단일 책임 원칙
## 수직, 수평 계층구조와 의존관계
1. 수평적 분리
   - UserDao와 UserService의 분리
   - 각각 담당하는 코드의 기능적인 관심에 따라 분리
   - 서로 불필요한 영향을 주지 않으며 독자적으로 확장이 가능
   - 같은 애플리케이션 로직을 담은 코드지만 내용에 따라 분리 
2. 수직적 분리
   - 트랜잭션 추상화
   - 애플리케이션 비지니스 로직과 로우레벨의 트랜잭션 기술이라는 아예 다른 계층의 특성을 갖는 코드

### 사용자 관리 모듈의 의존관계
- 애플리케이션 계층 : UserService, UserDao
    - 애플리케이션의 로직
    - 인터페이스와 DI를 통해 연결됨으로써 결합도가 낮아졌다.
- UserDao는 DB 연결을 생성하는 방법에 대해 독립적이다.
    - DataSource 인터페이스와 DI를 통해 추상화된 방식으로 로우레벨의 DB 연결 기술을 사용하기 때문이다.
- UserService는 구체적인 트랜잭션 기술에 독립적이다.
    - PlatformTransactionManager 인터페이스를 통한 추상화 계층을 사이에 두고 사용하기 때문이다.

## 단일 책임 원칙
> 단일 책임 원칙은 하나의 모듈은 한 가지 책임을 가져야 한다는 의미이다.<br>
> 하나의 모듈이 바뀌는 이유는 한 가지여야 한다고 설명할 수도 있다.
- UserService에서 JDBC Connection의 메소드를 직접 사용하는 트렉젠션 코드를 사용하고 있을 때를 생각해보자. 
- UserService는 어떻게 사용자 레벨을 관리할 것인가, 어떻게 트랜잭션을 관리 할 것인가 두가지 책임을 가지고 있었다.
- 두가지 책임을 가지고 있다는 건 코드가 수정되야할 이유가 두가지라는 뜻이다.
    1. 사용자의 레벨 업그레이드 정책과 같은 사용자 관리 로직이 바뀔 때
    2. 트랜잭션 기술을 JDBC에서 JTA로 변경해야 할 때  
- 하지만 트랙잰셕 서비스의 추상화 방식을 도입하고, 이를 DI를 통해 외부로 제어하도록 만들고 난 뒤에는 JDBC에서 JTA로 바뀌더라도 UserService 코드는 단 한줄도 수정할 이유가 없었다. 즉, UserService는 오직 사용자 관리에 대한 책임만 가지며 단일 책임 원칙을 충실히 지키게 되었다.
### 단일 책임 원칙의 장점
- 어떤 변경이 필요할 때 수정 대상이 명확해진다.
    - 만약 DAO가 각각 수백 개가 되고, 서비스 클래스도 그만큼 많다고 가정해보자. 서비스 하나가 여러개의 DAO를 사용하는 경우가 많아 질 것이다. 이떄, DAO를 수정했는데 그에 의존하는 서비스 클래스를 수정해야 한다면.. DAO를 사용하는 모든 서비스 클래스를 수정해야한다. 또, 이 때문에 수많은 테스트도 수정해야 할 수도 있다.
- 단일 책임 원칙을 잘 지키는 코드를 만들려면 인터페이스를 도입하고 이를 DI로 연결해야 한다. 그 결과 단일 책임 원칙 뿐만 아니라 OCP도 잘 지키고, 모듈 간의 결합도가 낮아져 서로의 변경에 영향을 주지 않고 같은 이유로 변경이 단일 책임에 집중되는 응집도가 높은 코드가 나온다.
