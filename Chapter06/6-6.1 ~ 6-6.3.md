## 트랜잭션 속성
![image](https://user-images.githubusercontent.com/37647995/117630538-441f5380-b1b6-11eb-8000-ba6fc8126141.png)
### 트랜잭션 정의
`DefaultTransactionDefinition` 이 구현하고 있는 `TransactionDefinition` 인터페이스는 트랜잭션의 동작방식에 영향을 줄 수 있는 네 가지 속성을 정의하고 있다.
#### 트랜잭션 전파
![image](https://user-images.githubusercontent.com/37647995/117630579-4e415200-b1b6-11eb-8f74-1abdc3f28f48.png)
- A의 트랜잭션이 시작되고 아직 끝나지 않은 시점에서 B를 호출했다면 B의 코드는 어떤 트랜잭션 안에서 동작해야 할까?
    1. A에서 이미 시작한 트랜잭션에 참여할 수 있다. 만약 B를 호출한 작업까지 마치고 (2)의 코드를 진행하던 중 예외가 발생했다고 하면 A,B 코드에서 진행했던 모든 DB 작업이 다 취소된다. A,B가 하나의 트랜잭션으로 묶여있기 때문이다.
    2. A의 트랜잭션과 무관하게 독립적인 트랜잭션으로 만들 수 있다. B는 트랜잭션 경계를 빠져 나오는 순간 독자적으로 커밋 또는 롤백 될 것이고, A 트랜잭션은 이에 영향을 받지 않고 진행될 것이다. 이후에 A의 (2) 코드에서 예외가 발생하여 A 트랜잭션은 롤백 되는 경우더라도 B에서 이미 종료된 트랜잭션의 결과에는 영향을 주지 않는다.
- 이렇게 B와 같이 독자적으로 트랜잭션 경계를 가진 코드가 이미 진행 중인 트랜잭션에 어떻게 영향을 미칠 수 있는 가를 정의하는 것이 트랜잭션 전파 속성이다.
- 트랜잭션 전파 속성의 종류
    1. `PROPAGATION_REQUIRED` : 가장 많이 사용되는 트랜잭션 전파 속성으로, 진행 중인 트랜잭션이 없으면 새로 시작하고, 이미 시작된 트랜잭션이 있으면 이에 참여한다. (`DefaultTransactionDefinition` 에 적용된 트랜잭션 전파 속성)
    2. `PROPAGATION_REQUIRES_NEW` : 항상 새로운 트랜잭션을 시작한다. 독립적인 트랜잭션이 보장되어야 하는 코드에 적용할 수 있다.
    3. `PROPAGATION_NOT_SUPPORTED` : 트랜잭션 없이 동작하도록 만들 수 있는 속성
- 트랜잭션 매니저의 `getTransaction()` 메소드는 트랜잭션 전파 속성에 따라 새로운 트랜잭션을 시작할 수도 있고, 이미 진행 중인 트랜잭션에 참여할 수도 있다.

#### 격리수준
- 모든 DB 트랜잭션은 격리 수준을 가지고 있어야 한다. 서버 환경에서는 여러 개의 트랜잭션이 동시에 실행 될 수 있기 때문에 격리 수준을 조정해서 가능한 많은 트랜잭션을 동시에 진행 시키면서도 문제가 발생하지 않게 하는 제어가 필요하다.
- `DefaultTransactionDefinition` 에 설정된 격리 수준은 `ISOLATION_DEFAULT` 이다. 이는 DataSource에 설정되어 있는 디폴트 격리 수준을 그대로 따른다는 뜻이다.

#### 제한 시간
- 트랜잭션을 수행하는 제한 시간을 설정 할 수 있다.
- `DefaultTransactionDefinition` 의 기본 설정은 제한 시간이 없는 것이다.

#### 읽기 전용
- 읽기 전용으로 설정해두면 트랜잭션 내에서 데이터를 조작하는 시도를 막아 줄 수 있다.

### 트랜잭션 인터셉터와 트랜잭션 속성
메소드 별로 다른 트랜잭션 정의를 적용하려면 어드바이스의 기능을 확장해야 한다.

#### TransactionInterceptor
- `TransactionInterceptor` 는 트랜잭션 정의를 메소드 이름 패턴을 이용해서 다르게 지정할 수 있는 방법을 제공해준다.
- `TransactionInterceptor` 는 `PlatformTransactionManager` 와 `Properties` 타입의 두가지 프로퍼티를 가지고 있다.
- `Properties` 타입은 두 번째 프로퍼티의 이름은 `transactionAttributes` 로 트랜잭션 속성을 정의한 프로퍼티이다.
- `transactionAttributes` 를 이용하면 트랜잭션 부가 기능의 동작 방식을 모두 제어할 수 있다.

#### 메소드 이름 패턴을 이용한 트랜잭션 속성 지정
- `Properties` 타입의 `transactionAttributes`  프로퍼티는 메소드 패턴과 트랜잭션 속성을 키와 값으로 갖는 컬렉션이다. 트랜잭션 속성은 아래와 같은 문자열로 정의할 수 있다.

  ![image](https://user-images.githubusercontent.com/37647995/117630644-5ef1c800-b1b6-11eb-8e85-59e7e246550f.png)
  - 모든 런타임 예외는 롤백 되어야 하지만 앞에 +를 붙여주면 런타임 예외라도 커밋하게 만들 수 있다. 반대로 체크 예외는 모두 커밋하는 것이 기본 처리 방식이지만 - 붙여서 넣어주면 롤백 할 수있다.
  
- 메소드 이름 패턴과 문자열로 된 트랜잭션 속성을 이용해서 정의한 `TransactionInterceptor`  타입 빈의 예시
  ![image](https://user-images.githubusercontent.com/37647995/117630699-6c0eb700-b1b6-11eb-84cf-8c9aa6cfe79c.png)


### 포인트 컷과 트랜잭션 속성의 적용 전략
#### 트랜잭션 포인트컷 표현식은 타입 패턴이나 빈 이름을 이용한다.
- 일반적으로 트랜잭션을 적용할 타깃 클래스의 메소드는 모두 트랜잭션 적용 후보가 되는 것이 바람직하다.
- 트랜잭션 경계로 삼을 클래스들이 선정됐다면, 그 클래스들이 모여 있는 패키지를 통째로 선택하거나, 클래스의 이름에서 일정한 패턴을 찾아서 표현식으로 만들면 된다.
- 관례적으로 비즈니스 로직 서비스를 담당하는 클래스 이름은 Service 또는 ServiceImpl로 끝나는 경우가 많은데 그런 경우라면 `execution(**..*ServiceImpl.*(..))` 와 같이 포인트 컷을 정의하면 된다.

#### 공통된 메소드 이름 규칙을 통해 최소한의 트랜잭션 어드바이스와 속성을 정의한다.
- 가장 간단한 트랜잭션 속성 부여 방법은 모든 메소드에 대해 디폴트 속성을 지정하는 것이다.
  ![image](https://user-images.githubusercontent.com/37647995/117630754-7a5cd300-b1b6-11eb-8490-93c0881ad53d.png)
- 디폴트 속성을 일괄적으로 부여한 것에서 한 단계 더 나아간다면, 간단한 메소드 이름의 패턴을 적용해 볼 수 있다.
  ![image](https://user-images.githubusercontent.com/37647995/117630772-7df05a00-b1b6-11eb-968e-2b1ee26a038e.png)
- 일반화 하기에 적당하지 않은 특별한 트랜잭션 속성이 필요한 타깃 오브젝트에 대해서는 별도의 어드바이스와 포인트컷 표현식을 사용하는 편이 좋다.

  ![image](https://user-images.githubusercontent.com/37647995/117630799-85affe80-b1b6-11eb-87c3-461e32e0e433.png)


#### 프록시 방식 AOP는 같은 타깃 오브젝트 내의 메소드를 호출할 때는 적용되지 않는다.(전략이라기 보다는 주의사항 느낌)
- 프록시 방식의 AOP 에서는 프록시를 통한 부가 기능의 적용은 클라이언트(인터페이스를 통해 타킷 오브젝트를 사용하는 다른 모든 오브젝트)로부터 호출이 일어날 때만 가능하다.
- 타깃 오브젝트가 자기 자신의 메소드를 호출할 때는 프록시를 통한 부가 기능의 적용이 일어나지 않는다.
  ![image](https://user-images.githubusercontent.com/37647995/117630835-8ea0d000-b1b6-11eb-98e0-e133c6780716.png)
- [2]의 경우처럼 타깃 오브젝트로 들어와서 타깃 오브젝트 내의 메소드를 호출하는 경우에는 update() 메소드에 지정된 트랜잭션 속성이 전혀 반영되지 않는다.
